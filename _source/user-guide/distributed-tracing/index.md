---
layout: article
title: Distributed Tracing
permalink: /user-guide/distributed-tracing/
flags:
  logzio-plan: community
  beta: true
tags:
  - distributed tracing
contributors:
  - yberlinger
---


### Yes, you _can_ have it all!

Maximize your value with the Logz.io end-to-end system observability platform and use open source as a service for: 

* Infrastructure monitoring - to understand a pattern or trend (measure/monitor... is my service slowing down?)
* Log management - to debug an individual issue or problem (diagnostics... how do I fix the problem?)
* Distributed tracing - to identify when and where performance issues or errors are occurring within a specific transaction, and isolate the contributing causes of these issues

### Why go it alone? 

Gain a system-wide view of your distributed architecture, detect failed or high latency requests, and quickly drill into end-to-end call sequences of selected requests of intercommunicating microservices. Logz.io Distributed Tracing provides Jaeger as a fully managed open source service - so DevOps teams can use the best cloud-native open source tracing tool - without running it themselves. 

Logz.io gives you granularity to look under the hood at how your microservices are interacting and lets you access rich information that engineers can use to improve performance and investigate - and then troubleshoot - potential microservice issues.


<iframe width="560" height="315" src="https://www.youtube.com/embed/yYM_qLr__Ow" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### So what _is_ distributed tracing?

Distributed tracing is a way to monitor applications, especially those built with microservices. Distributed tracing helps you pinpoint where failures occur and the leading contributors to slow transactions or poor transaction performance when you analyze a map of the requests made to other services within the main transaction call.

### Traces and spans
A **trace** is a single transaction request generated by a user or API call, which in turn uses other services and resources. The trace maps the execution path the request takes through the system. Each trace is composed of a varying number of child requests to other components within the system which must all be executed for the transaction to be successful.  

A **span** is the primary building block of a distributed trace. Spans represent an individual unit of work done in a distributed system. Each request to a component within the distributed system contributes a span - a named, timed operation representing a piece of the workflow. The tracing instrumentation collects this transaction data (the timing, metadata, and other details), and assigns assigns a unique trace ID to each trace and a unique span ID to each span within the trace.

Depending on the instrumentation tools and methods chosen, spans may contain “references” to other spans, which allows multiple spans to be assembled into one complete trace - a visualization of the life of a request as it moves through various microservices in a distributed systems. The edges between the spans which make up a trace indicate parent/child relationships.

DevOps teams can use distributed tracing to monitor the requests in their system from a high-level, and then dig into specific requests as issues arise.

Each span is defined by its:

* Operation name
* Start timestamp, and span duration 
* Set of span tags: These `key:value` pair tags enable user-defined span annotations. You can use these tags to query, filter, and understand trace data
* Span Logs, which include information about the exceptions or error that occured in the request

###### Example

A service with a unique ID executes within the system and calls microservices A through E. Each microservice request returns a response.

Microservice A is the edge service at which the transaction execution begins. 
This service first calls microservice B, and then calls microservice E after microservice B begins to execute.
Microservice B calls microservices C and D.   

Logz.io visualizes and maps application requests as they execute across microservices. We represent the microservice calls by time spans: Each bar in the image below is a span. 

All of these spans together make up the full trace. 
![services to spans](https://dytvr9ot2sszz.cloudfront.net/logz-docs/distributed-tracing/tracing_micropans.png)

### Quick Links: Oh, the Traces You'll Go! 

* [Get started](/user-guide/distributed-tracing/getting-started-tracing): Deploy components and set up instrumentation
* [Search for traces](/user-guide/distributed-tracing/tracing-tour): Log in and get on the trace 
* [View the trace timeline](/user-guide/distributed-tracing/trace-timeline): Dig into the details of each span
* [Compare traces](/user-guide/distributed-tracing/compare-traces): See where traces differ from each other by comparing node blocks
* [Correlate logs and traces](/user-guide/distributed-tracing/correlate-traces): Harness Kibana and Jaeger for even more powerful insights.

### Further reading 

* <a href ="https://logz.io/tag/distributed-tracing/" target="_blank">Logz.io Distributing Tracing blog</a>  
* <a href ="https://logz.io/tag/Jaeger/" target="_blank">Logz.io blog articles on Jaeger</a> 
* <a href ="https://logz.io/blog/jaeger-kubernetes-best-practices/" target="_blank">Deploying Jaeger on Kubernetes</a> 
* <a href ="https://logz.io/blog/jaeger-persistence/" target="_blank">Jaeger Persistent Storage</a>
* <a href ="https://www.youtube.com/watch?v=zb0fdU6c0KU" target="_blank">Jaeger deep-dive <i class="fas fa-external-link-alt"></i></a> 
* <a href ="https://www.jaegertracing.io" target="_blank">Jaegertracing.io <i class="fas fa-external-link-alt"></i></a> 
* <a href ="https://medium.com/jaegertracing" target="_blank">Jaeger on Medium <i class="fas fa-external-link-alt"></i></a>
* <a href ="https://gitter.im/jaegertracing/Lobby" target="_blank">Jaeger tracing community chat <i class="fas fa-external-link-alt"></i></a> 


